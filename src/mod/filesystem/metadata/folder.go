package metadata

import (
	"errors"
	"image"
	"image/draw"
	"image/jpeg"
	"image/png"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/nfnt/resize"
)

/*
	Generate folder thumbnail from the containing files
	The preview is generated by overlapping 2 - 3 layers of images
*/

func generateThumbnailForFolder(cacheFolder string, file string, generateOnly bool) (string, error) {
	//Check if this folder has cache image folder
	cacheFolderInsideThisFolder := filepath.Join(file, "/.metadata/.cache")
	if !fileExists(cacheFolderInsideThisFolder) {
		//This folder do not have a cache folder
		return "", errors.New("No previewable files")
	}

	//Load the base template
	if !fileExists("web/img/system/folder-preview.png") {
		//Missing system files. Skip rendering
		return "", errors.New("Missing system template image file")
	}
	image1, err := os.Open("web/img/system/folder-preview.png")
	if err != nil {
		return "", err
	}

	baseTemplate, err := png.Decode(image1)
	if err != nil {
		return "", err
	}
	image1.Close()

	//Generate the base image
	b := baseTemplate.Bounds()
	resultThumbnail := image.NewRGBA(b)
	draw.Draw(resultThumbnail, b, baseTemplate, image.ZP, draw.Over)

	//Get cached file inside this folder, only include jpg (non folder)
	contentCache, _ := wGlob(filepath.Join(cacheFolderInsideThisFolder, "/*.jpg"))

	//Check if there are more than 1 file inside this folder that is cached
	if len(contentCache) > 1 {
		//More than 1 files. Render the image at the back
		image2, err := os.Open(contentCache[1])
		if err != nil {
			return "", err
		}
		backImage, err := jpeg.Decode(image2)
		if err != nil {
			return "", err
		}
		backImgOffset := image.Pt(155, 110)
		defer image2.Close()
		resizedBackImg := resize.Resize(250, 250, backImage, resize.Lanczos3)
		draw.Draw(resultThumbnail, resizedBackImg.Bounds().Add(backImgOffset), resizedBackImg, image.ZP, draw.Over)
	} else {
		//Nothing to preview inside this folder
		return "", errors.New("No previewable files")
	}

	//Render the top image
	image3, err := os.Open(contentCache[0])
	if err != nil {
		return "", errors.New("failed to open: " + err.Error())
	}

	topImage, err := jpeg.Decode(image3)
	if err != nil {
		//Fail to decode the image. Try to remove the damaged iamge file
		image3.Close()
		os.Remove(contentCache[0])
		log.Println("Failed to decode cahce image for: " + contentCache[0] + ". Removing thumbnail cache")
		return "", errors.New("failed to decode: " + err.Error())
	}
	defer image3.Close()

	topImageOffset := image.Pt(210, 210)
	resizedTopImage := resize.Resize(260, 260, topImage, resize.Lanczos3)
	draw.Draw(resultThumbnail, resizedTopImage.Bounds().Add(topImageOffset), resizedTopImage, image.ZP, draw.Over)

	outfile, err := os.Create(filepath.Join(cacheFolder, filepath.Base(file)+".png"))
	if err != nil {
		log.Fatalf("failed to create: %s", err)
	}
	png.Encode(outfile, resultThumbnail)
	outfile.Close()

	ctx, err := getImageAsBase64(cacheFolder + filepath.Base(file) + ".png")
	return ctx, err
}

//Special glob function to handle file name containing wildcard characters
func wGlob(path string) ([]string, error) {
	files, err := filepath.Glob(path)
	if err != nil {
		return []string{}, err
	}

	if strings.Contains(path, "[") == true || strings.Contains(path, "]") == true {
		if len(files) == 0 {
			//Handle reverse check. Replace all [ and ] with ?
			newSearchPath := strings.ReplaceAll(path, "[", "?")
			newSearchPath = strings.ReplaceAll(newSearchPath, "]", "?")
			//Scan with all the similar structure except [ and ]
			tmpFilelist, _ := filepath.Glob(newSearchPath)
			for _, file := range tmpFilelist {
				file = filepath.ToSlash(file)
				if strings.Contains(file, filepath.ToSlash(filepath.Dir(path))) {
					files = append(files, file)
				}
			}
		}
	}
	//Convert all filepaths to slash
	for i := 0; i < len(files); i++ {
		files[i] = filepath.ToSlash(files[i])
	}
	return files, nil
}
